---
phase: 05-agent-health-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/claude_teams/server.py
  - tests/test_server.py
autonomous: true

must_haves:
  truths:
    - "Team lead can call check_agent_health MCP tool to get status of a specific agent"
    - "Team lead can call check_all_agents_health MCP tool to get status of all agents in the team"
    - "Health check results include status (alive/dead/hung/unknown), agent name, pane ID, and detail text"
    - "check_all_agents_health persists health state so subsequent calls can detect hung agents"
    - "Nonexistent agent name returns a ToolError, not a crash"
  artifacts:
    - path: "src/claude_teams/server.py"
      provides: "check_agent_health and check_all_agents_health MCP tools"
      contains: "def check_agent_health"
    - path: "tests/test_server.py"
      provides: "Tests for health check MCP tools"
      contains: "TestCheckAgentHealth"
  key_links:
    - from: "src/claude_teams/server.py"
      to: "src/claude_teams/spawner.py"
      via: "check_pane_alive, check_single_agent_health imports"
      pattern: "from claude_teams.spawner import.*check_pane_alive"
    - from: "src/claude_teams/server.py"
      to: "src/claude_teams/models.py"
      via: "AgentHealthStatus import"
      pattern: "from claude_teams.models import.*AgentHealthStatus"
---

<objective>
Expose health detection as MCP tools: `check_agent_health` for a single agent and `check_all_agents_health` for batch health checking with automatic health state persistence for hung detection.

Purpose: Make health detection accessible to the team lead via MCP tool calls, satisfying RELY-03 and enabling RELY-04 (team lead can detect dead/hung agents and then call existing `force_kill_teammate` to act on them).
Output: Two new MCP tools in server.py, integration tests validating the full flow.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-health-monitoring/05-RESEARCH.md
@.planning/phases/05-agent-health-monitoring/05-01-SUMMARY.md
@src/claude_teams/server.py
@src/claude_teams/spawner.py
@src/claude_teams/models.py
@tests/test_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add check_agent_health and check_all_agents_health MCP tools</name>
  <files>src/claude_teams/server.py</files>
  <action>
**Imports:** Add to the existing import from `claude_teams.spawner`: `check_pane_alive`, `check_single_agent_health`, `load_health_state`, `save_health_state`. Add `AgentHealthStatus` to the import from `claude_teams.models`.

**Add two new MCP tools** in server.py, after the existing `process_shutdown_approved` tool and before `main()`:

1. **`check_agent_health` tool:**
   ```python
   @mcp.tool
   def check_agent_health(
       team_name: str,
       agent_name: str,
   ) -> dict:
       """Check health status of a specific agent. Returns status: 'alive', 'dead',
       'hung', or 'unknown'. Dead means the tmux pane no longer exists. Hung means
       the pane is alive but has produced no new output for over 120 seconds.
       Use force_kill_teammate to kill dead or hung agents."""
       config = teams.read_config(team_name)
       member = None
       for m in config.members:
           if isinstance(m, TeammateMember) and m.name == agent_name:
               member = m
               break
       if member is None:
           raise ToolError(f"Agent {agent_name!r} not found in team {team_name!r}")

       # Load previous health state for hung detection
       health_state = load_health_state(team_name)
       agent_state = health_state.get(agent_name, {})
       previous_hash = agent_state.get("hash")
       last_change_time = agent_state.get("last_change_time")

       result = check_single_agent_health(
           member,
           previous_hash=previous_hash,
           last_change_time=last_change_time,
       )

       # Update health state
       import time
       if result.last_content_hash is not None:
           if result.last_content_hash != previous_hash:
               health_state[agent_name] = {
                   "hash": result.last_content_hash,
                   "last_change_time": time.time(),
               }
           elif agent_name not in health_state:
               health_state[agent_name] = {
                   "hash": result.last_content_hash,
                   "last_change_time": time.time(),
               }
       save_health_state(team_name, health_state)

       return result.model_dump(by_alias=True, exclude_none=True)
   ```

   Note: `time` is already imported at top of server.py. Move the import to use the existing one rather than re-importing inside the function.

2. **`check_all_agents_health` tool:**
   ```python
   @mcp.tool
   def check_all_agents_health(
       team_name: str,
   ) -> list[dict]:
       """Check health of all teammates in the team. Returns a list of health
       status objects. Each includes agentName, paneId, status, and detail.
       Useful for monitoring team health. Automatically persists health state
       for hung detection across calls."""
       config = teams.read_config(team_name)
       health_state = load_health_state(team_name)
       results = []

       for m in config.members:
           if not isinstance(m, TeammateMember):
               continue
           agent_state = health_state.get(m.name, {})
           previous_hash = agent_state.get("hash")
           last_change_time = agent_state.get("last_change_time")

           status = check_single_agent_health(
               m,
               previous_hash=previous_hash,
               last_change_time=last_change_time,
           )

           # Update health state for this agent
           if status.last_content_hash is not None:
               if status.last_content_hash != previous_hash:
                   health_state[m.name] = {
                       "hash": status.last_content_hash,
                       "last_change_time": time.time(),
                   }
               elif m.name not in health_state:
                   health_state[m.name] = {
                       "hash": status.last_content_hash,
                       "last_change_time": time.time(),
                   }

           results.append(status.model_dump(by_alias=True, exclude_none=True))

       save_health_state(team_name, health_state)
       return results
   ```

Both tools follow the existing server.py patterns: read team config, validate member exists, return model_dump with by_alias=True and exclude_none=True.
  </action>
  <verify>Run `python -c "from claude_teams.server import mcp; tools = [t.name for t in mcp._tool_manager.list_tools()]; assert 'check_agent_health' in tools and 'check_all_agents_health' in tools; print('OK')"` -- should print OK.</verify>
  <done>check_agent_health and check_all_agents_health MCP tools are registered in the FastMCP server, with correct parameter types, docstrings, and health state persistence logic.</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for health check MCP tools</name>
  <files>tests/test_server.py</files>
  <action>
Add test classes to `tests/test_server.py` for the new MCP tools. Follow the existing test patterns in that file (use `fastmcp.Client` context manager if that pattern exists, or use direct function calls with mocked context if that is the pattern).

Look at how existing MCP tool tests are structured in test_server.py and follow the same pattern. The tests should mock `claude_teams.spawner.check_pane_alive` and `claude_teams.spawner.capture_pane_content_hash` at the module level to control tmux responses.

**TestCheckAgentHealth:**

1. `test_returns_alive_for_live_agent` -- Create a team with a teammate member (mock spawn or directly add member via teams module). Mock check_pane_alive=True, capture_pane_content_hash returns a hash. Call check_agent_health tool. Assert status=="alive".

2. `test_returns_dead_for_missing_pane` -- Same setup. Mock check_pane_alive=False. Call tool. Assert status=="dead".

3. `test_raises_for_unknown_agent` -- Create team. Call check_agent_health with nonexistent agent name. Assert ToolError is raised.

4. `test_returns_hung_on_second_call_with_unchanged_content` -- This tests the state persistence. First call: mock alive=True, hash="abc". Second call: same hash, enough time passed (mock time.time to advance). Assert second call returns status=="hung". This may need to mock `time.time` to simulate time passage, OR set last_change_time to a past value in health state manually before the second call.

**TestCheckAllAgentsHealth:**

1. `test_returns_status_for_all_teammates` -- Create a team with 2 teammates. Mock check_pane_alive to return True for both. Call check_all_agents_health. Assert result is a list with 2 entries, both with status info.

2. `test_excludes_lead_member` -- Verify the lead member is not included in health check results. The result list should only contain teammate members.

3. `test_returns_empty_list_for_no_teammates` -- Create a team with no teammates. Call tool. Assert empty list.

Use the existing team creation fixtures/patterns from test_server.py. For adding teammate members to the config, either use `teams.add_member()` directly (faster, no tmux needed) or reuse existing helpers.

The health state file tests should use `tmp_claude_dir` or `base_dir` monkeypatching so they write to temp directories, not the real `~/.claude/`.

If test_server.py uses MCP Client-based testing (async tests with `async with Client(mcp) as client`), follow that pattern. If it uses direct function calls, follow that instead.
  </action>
  <verify>Run `python -m pytest tests/test_server.py -v -k "TestCheckAgentHealth or TestCheckAllAgentsHealth"` -- all new tests pass.</verify>
  <done>7+ integration tests pass covering: alive detection, dead detection, unknown agent error, hung detection with state persistence, batch health check, lead exclusion, empty team handling.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass (existing + new)
2. MCP tools are discoverable: `check_agent_health` and `check_all_agents_health` appear in tool list
3. Health state file is created/updated by MCP tools (verified via test)
4. Hung detection works across multiple calls (state persistence verified)
</verification>

<success_criteria>
- check_agent_health MCP tool returns correct status for alive/dead/hung/unknown agents
- check_all_agents_health MCP tool returns status for all teammates (excludes lead)
- Health state persists between tool calls enabling hung detection
- ToolError for nonexistent agents
- All existing tests still pass
- 7+ new integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-health-monitoring/05-02-SUMMARY.md`
</output>
